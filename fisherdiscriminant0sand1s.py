# -*- coding: utf-8 -*-
"""FisherDiscriminant0sand1s.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16-5egvp60Bomr77M4fLihO6mjbZkJfLp

## **Import packages**

## **Load and visualize MNIST da   t  a**
"""

import numpy as np
import matplotlib.pyplot as plt
from keras.datasets import mnist
from skimage import measure

import warnings
warnings.filterwarnings("ignore") # Added this at the end to show a clean output with no warnings but not necessary

"""### Choose number to visualize (from 0 to 9):"""

(x_train, y_train), (x_test, y_test) = mnist.load_data()

number0 = 0
x_0 = x_train[y_train==number0,:,:]
print('The shape of 0 is:')
print(x_0.shape)
print('which means:')
print('Number '+str(number0)+' has '+str(x_0.shape[0])+' images of size '+str(x_0.shape[1])+'x'+str(x_0.shape[2]))


print()
number1 = 1
x_1 = x_train[y_train==number1,:,:]
print('The shape of 1 is:')
print(x_1.shape)
print('which means:')
print('Number '+str(number1)+' has '+str(x_1.shape[0])+' images of size '+str(x_1.shape[1])+'x'+str(x_1.shape[2]))

"""### Plot average image:"""

m0 = np.mean(x_0, axis=0) # IMPORTANT: indexes in python start at "0", not "1", so the first element of array "a" would be a[0]

plt.figure()
plt.subplot(2,2,1)
plt.imshow(m0)
plt.title('Average "0" image')

mt0 = 1*(m0 > 60) # Thresholding
plt.subplot(2,2,2)
plt.imshow(mt0)
plt.title('Thresholded "0" image')

m1 = np.mean(x_1, axis=0) # IMPORTANT: indexes in python start at "0", not "1", so the first element of array "a" would be a[0]

plt.figure()
plt.subplot(2,2,3)
plt.imshow(m1)
plt.title('Average "1" image')

mt1 = 1*(m1 > 60) # Thresholding
plt.subplot(2,2,4)
plt.imshow(mt1)
plt.title('Thresholded "1" image')

"""## From a thresholded image, we can use the regionprops function from skimage.measure"""

mt0_props = measure.regionprops(mt0)
num_regions = len(mt0_props)
print(str(num_regions)+' region/s were found. Handwritten 0s')
print('')

print('Area (in pixels):')
area = mt0_props[0].area # Remember, index 0 is the first region found
print(area)
print('')

print('Perimeter (in pixels):')
perimeter = mt0_props[0].perimeter
print(perimeter)
print('')

print('Centroid (pixel coordinates):')
centroid = mt0_props[0].centroid
print(centroid)

print('Eccentricity:')
eccentricity = mt0_props[0].eccentricity
print(eccentricity)
print('')

print('Minor axis length:')
minor_axis = mt0_props[0].minor_axis_length
print(minor_axis)
print('')

mt1_props = measure.regionprops(mt1)
num_regions = len(mt1_props)
print(str(num_regions)+' region/s were found. Handwritten 1s')
print('')

print('Area (in pixels):')
area = mt1_props[0].area # Remember, index 0 is the first region found
print(area)
print('')

print('Perimeter (in pixels):')
perimeter = mt1_props[0].perimeter
print(perimeter)
print('')

print('Centroid (pixel coordinates):')
centroid = mt1_props[0].centroid
print(centroid)

print('Eccentricity:')
eccentricity = mt1_props[0].eccentricity
print(eccentricity)
print('')

print('Minor axis length:')
minor_axis = mt1_props[0].minor_axis_length
print(minor_axis)
print('')

"""##Scatter plot of Area vs Perimeter for all images of numbers "0" and "1""""

x0 = x_train[y_train==0,:,:]
x1 = x_train[y_train==1,:,:]

# Threshold images
t0 = 1*(x0 > 60)
t1 = 1*(x1 > 60)

# Region properties
area0 = np.zeros(t0.shape[0])
perimeter0 = np.zeros(t0.shape[0])
minor_axis_length0 = np.zeros(t0.shape[0])
for i in range(0,t0.shape[0]):
  props = measure.regionprops(t0[i,:,:])
  area0[i] = props[0].area
  perimeter0[i] = props[0].perimeter
  minor_axis_length0[i] = props[0].minor_axis_length
  
area1 = np.zeros(t1.shape[0])
perimeter1 = np.zeros(t1.shape[0])
minor_axis_length1 = np.zeros(t1.shape[0])
for i in range(0,t1.shape[0]):
  props = measure.regionprops(t1[i,:,:])
  area1[i] = props[0].area
  perimeter1[i] = props[0].perimeter
  minor_axis_length1[i] = props[0].minor_axis_length
  
plt.figure(figsize=(20,5))
plt.subplot(1,2,1)
plt.scatter(area0,perimeter0, label='Number 0')
plt.scatter(area1,perimeter1, label='Number 1')
plt.title('All images for both classes')
plt.legend()

plt.subplot(1,2,2)
plt.scatter(area0[0:100],perimeter0[0:100], label='Number 0')
plt.scatter(area1[0:100],perimeter1[0:100], label='Number 1')
plt.title('100 images of each class')
plt.legend()

X0 = np.zeros((t0.shape[0],2))
for i in range(0,t0.shape[0]):
  X0[i] = [area0[i],perimeter0[i]]
  
X1 = np.zeros((t1.shape[0],2))
for i in range(0,t1.shape[0]):
  X1[i] = [area1[i],perimeter1[i]]

  
X = np.append(X0,X1,axis = 0)

print('0s class:\n', X0)
print('1s class:\n', X1)
print('Two classes together:\n', X)

#Mean Vectors

m0 = np.mean(X0, axis=0)
m1 = np.mean(X1, axis=0)

m_overall = np.mean(X, axis=0)

print('0s mean:\n', m0)
print('1s mean:\n', m1)
print('Overall mean:\n', m_overall)

#Scatter Matrix

  #Within-Class Scatter
  SW = np.zeros((2,2))
  
  for i in X0:
    i,m0 = i.reshape(2,1), m0.reshape(2,1)
    SW += (i-m0).dot((i-m0).T)

  for i in X1:
    i,m1 = i.reshape(2,1), m1.reshape(2,1)
    SW += (i-m1).dot((i-m1).T)
    
  print('Within-Class Scatter Matrix:\n', SW)
  
  #Between-Class Scatter
  SB = np.zeros((2,2))  
  m0,m1,m_overall = m0.reshape(2,1), m1.reshape(2,1), m_overall.reshape(2,1)
  SB = t0.shape[0]*(m0-m_overall).dot((m0-m_overall).T) + t1.shape[0]*(m1-m_overall).dot((m1-m_overall).T)
  
  print('Between-Class Scatter Matrix:\n', SB)

#Eigenvalues for scatter matrices
eig_vals, eig_vecs = np.linalg.eig(np.linalg.inv(SW).dot(SB))

for i in range(len(eig_vals)):
    eigvec_sc = eig_vecs[:,i].reshape(2,1)   
    print('\nEigenvector {}: \n{}'.format(i+1, eigvec_sc.real))
    print('Eigenvalue {:}: {:.2e}'.format(i+1, eig_vals[i].real))

# Make a list of (eigenvalue, eigenvector) tuples
eig_pairs = [(np.abs(eig_vals[i]), eig_vecs[:,i]) for i in range(len(eig_vals))]

# Sort the (eigenvalue, eigenvector) tuples from high to low
eig_pairs = sorted(eig_pairs, key=lambda k: k[0], reverse=True)

# Visually confirm that the list is correctly sorted by decreasing eigenvalues

print('Eigenvalues in decreasing order:\n')
for i in eig_pairs:
    print(i[0])

w = -1*np.hstack((eig_pairs[0][1].reshape(2,1)))
print('w:\n', w)

#Threshold calculation
T = (np.dot(w, m0)+np.dot(w, m1))*0.5
print(T)

fails = 0

for i in X0:
  if(np.dot(w, i) < T):     
     fails += 1

for i in X1:
  if(np.dot(w, i) > T):
     fails += 1

      
print('Accuracy: ',(1-(fails/X.shape[0]))*100)

x0test = x_test[y_test==0,:,:]
x1test = x_test[y_test==1,:,:]

# Threshold images
t0test = 1*(x0test > 60)
t1test = 1*(x1test > 60)

# Region properties
area0test = np.zeros(t0test.shape[0])
perimeter0test = np.zeros(t0test.shape[0])
minor_axis_length0test = np.zeros(t0test.shape[0])
for i in range(0,t0test.shape[0]):
  propstest = measure.regionprops(t0[i,:,:])
  area0test[i] = propstest[0].area
  perimeter0test[i] = propstest[0].perimeter
  minor_axis_length0test[i] = propstest[0].minor_axis_length
  
area1test = np.zeros(t1test.shape[0])
perimeter1test = np.zeros(t1test.shape[0])
minor_axis_length1test = np.zeros(t1test.shape[0])
for i in range(0,t1test.shape[0]):
  propstest = measure.regionprops(t1test[i,:,:])
  area1test[i] = propstest[0].area
  perimeter1test[i] = propstest[0].perimeter
  minor_axis_length1test[i] = propstest[0].minor_axis_length

X0test = np.zeros((t0test.shape[0],2))
for i in range(0,t0test.shape[0]):
  X0test[i] = [area0test[i],perimeter0test[i]]
  
X1test = np.zeros((t1test.shape[0],2))
for i in range(0,t1test.shape[0]):
  X1test[i] = [area1test[i],perimeter1test[i]]

  
Xtest = np.append(X0test,X1test,axis = 0)

print(t0test.shape[0])
print(t1test.shape[0])
print('0s class:\n', X0test)
print('1s class:\n', X1test)
print('Two classes together:\n', Xtest)

failstest = 0

for i in X0test:
  if(np.dot(w, i) < T):     
     failstest += 1
    
for i in X1test:
  if(np.dot(w, i) > T):
     failstest += 1

      
print('Accuracy: ',(1-(failstest/Xtest.shape[0]))*100)